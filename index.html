<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>BusDriver Toolbox by dspKitchen</title>

    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/github-dark.css">
    <script src="javascripts/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="wrapper">
      <header>
        <h1>BusDriver Toolbox</h1>
        <p>IC Communication for MATLAB®</p>
        <p class="view"><a href="https://github.com/dspKitchen/BusDriverToolbox">View the Project on GitHub <small>dspKitchen/BusDriverToolbox</small></a></p>
        <ul>
          <li><a href="https://github.com/dspKitchen/BusDriverToolbox/zipball/master">Download <strong>ZIP File</strong></a></li>
          <li><a href="https://github.com/dspKitchen/BusDriverToolbox/tarball/master">Download <strong>TAR Ball</strong></a></li>
          <li><a href="https://github.com/dspKitchen/BusDriverToolbox">View On <strong>GitHub</strong></a></li>
        </ul>
      </header>
      <section>
        <p><strong>Schedule</strong> – <em>BusDriver</em> lets you interface MATLAB® directly to ICs performing analog and digital I/O. You can sense data for analysis and visualisation, generate data for control and test automation or even close the loop by inserting some fancy computations in between. It offers build-in support on high level abstraction for: </p>

<ul>
<li>GPIO, <a href="#an_001-interfacing-matlab-to-ics-via-gpio">AN_001</a>
</li>
<li>UART, <a href="#an_002-interfacing-matlab-to-ics-via-uart">AN_002</a>
</li>
<li>SPI,  <a href="#an_003-interfacing-matlab-to-ics-via-spi">AN_003</a>
</li>
<li>I2C,  <a href="#an_004-interfacing-matlab-to-ics-via-i2c">AN_004</a>
</li>
</ul>

<p><strong>Shift up a Gear</strong> – <em>BusDriver</em> supports MATLAB code generation capabilities to get your products real more quickly within a single tool chain. <em>BusDriver</em> is your powerfull companion driving you from rapid prototyping to series product development in no time.</p>

<p><strong>Ticket Check</strong> – <em>BusDriver</em> is released under commercial and <a href="https://www.gnu.org/licenses/old-licenses/gpl-2.0.html">GNU GPL v.2</a> open source licenses. Once your project becomes commercialised GPLv2 licensing dictates that you need to either open your source fully or purchase a commercial license. DspKitchen offer commercial licenses without any GPL restrictions. <a href="https://github.com/dspKitchen">Contact us for pricing</a>.</p>

<h2>
<a id="next-stop--geeting-started-with-busdriver" class="anchor" href="#next-stop--geeting-started-with-busdriver" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a><strong>Next Stop</strong> – Geeting Started with <em>BusDriver</em>
</h2>

<ol>
<li>Start up MATLAB win64 (Recommended is R2016a, but older versions will probably work fine)</li>
<li>
<p>Downlaod and install <em>BusDriver</em> Toolbox from within MATLAB command window by executing the following lines of code</p>

<div class="highlight highlight-source-matlab"><pre><span class="pl-c">%% Make installation directory</span>
installationDirectory = <span class="pl-k">fullfile</span>(<span class="pl-k">pwd</span>, <span class="pl-s"><span class="pl-pds">'</span>BusDriverToolbox<span class="pl-pds">'</span></span>);
<span class="pl-k">mkdir</span>(installationDirectory)

<span class="pl-c">%% Download and unzip BusDriver Toolbox</span>
urlBusDriver = <span class="pl-s"><span class="pl-pds">'</span>https://github.com/dspKitchen/BusDriverToolbox/archive/master.zip<span class="pl-pds">'</span></span>;
<span class="pl-k">unzip</span>(urlBusDriver, installationDirectory);

<span class="pl-c">%% Add BusDriver Toolbox to seach path</span>
<span class="pl-k">addpath</span>(installationDirectory);</pre></div>
</li>
<li>
<p>Plug in a <a href="#supported-usb-to-serial-converter">supported USB-to-serial converter</a>, e.g.</p>

<ul>
<li>Mikroelektronika <a href="http://www.mikroe.com/click/usb-adapter/">click USB adapter</a> (<strong>Recommended</strong> due to its superior choice of ready to use <a href="http://www.mikroe.com/click/">click boards™</a>)</li>
<li>Adafruit <a href="https://www.adafruit.com/products/2264">FT232H Breakout</a> (<strong>Hint</strong> – This board is quite cheep)</li>
<li>FTDI <a href="http://www.ftdichip.com/Products/Modules/DevelopmentModules.htm#UM232H-B">FT232H M232H-B</a><br>
</li>
<li>FTDI <a href="http://www.ftdichip.com/Products/Modules/DevelopmentModules.htm#FT2232H_Mini">FT2232H mini module</a>
</li>
<li>FTDI <a href="http://www.ftdichip.com/Products/Modules/DevelopmentModules.htm#FT4232H_Mini">FT4232H mini module</a> (<strong>Hint</strong> – For all those who operate up to 4 ICs in parallel)</li>
</ul>
</li>
<li>
<p>Check whether your USB-to-serial converter is recognised by <em>BusDriver</em>  </p>

<pre><code>&gt;&gt; deviceTable = BusDriver.getDevices()
deviceTable = 
            Description       SerialNumber    Flag    Type       ID       LocationID
         _________________    ____________    ____    ____    ________    __________

    0    'Dual RS232-HS A'    'A'             2       6       67330064    202017    
    1    'Dual RS232-HS B'    'B'             2       6       67330064    202018    

&gt;&gt; deviceNumber = BusDriver.getDeviceNumber('Dual RS232-HS A')
deviceNumber =
     0
</code></pre>
</li>
<li><p>You have done it - the engine runs fine! Now, attach an IC of choise to the USB-to-serial converter and let <em>BusDriver</em> hit the road.</p></li>
</ol>

<h2>
<a id="itinerary--on-how-to-go-with-busdriver" class="anchor" href="#itinerary--on-how-to-go-with-busdriver" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Itinerary – On how to go with <em>BusDriver</em>
</h2>

<h4>
<a id="an_001-interfacing-matlab-to-ics-via-gpio" class="anchor" href="#an_001-interfacing-matlab-to-ics-via-gpio" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>AN_001 <em>Interfacing MATLAB to ICs via GPIO</em>
</h4>

<p>Connect the pins and execute the file <em>AN_001.m</em> as follows</p>

<ul>
<li>ADBUS0 (D0) and ADBUS4 (D4), notably hardwired loopback of D0 and D4</li>
<li>ADBUS1 (D1) and ADBUS5 (D5), notably hardwired loopback of D1 and D5</li>
<li>ADBUS2 (D2) and ADBUS6 (D6), notably hardwired loopback of D2 and D6</li>
<li>ADBUS3 (D3) and ADBUS7 (D7), notably hardwired loopback of D3 and D7</li>
</ul>

<pre><code>&gt;&gt; deviceId = 0;
&gt;&gt; AN_001(deviceId)
Elapsed time for 1000 writes /sec = 0.16505
Elapsed time for 1000 reads  /sec = 0.18014

ans =

     1     1     0     0     1     1     0     0
</code></pre>

<p>And here goes the code ... </p>

<div class="highlight highlight-source-matlab"><pre><span class="pl-c">% Application Note AN_001, version 1.0.0</span>

<span class="pl-k">function</span> <span class="pl-v">levelGet</span> = <span class="pl-en">AN_001</span>(<span class="pl-v">devId</span>)
<span class="pl-c">%% Initialize the interface</span>
H = HGpio();            <span class="pl-c">% Returns a GPIO object, H, to eighter drive or sense certain I/O-Pins</span>
H.deviceNumber = devId; <span class="pl-c">% Must be 0 if only one device / channel is attached. Otherwise use 1, 2 etc.</span>
H.direction = [...      <span class="pl-c">% Sets the direction for (A/B)DBUS 0:7 to either HGpio.IN or HGpio.OUT</span>
    HGpio.IN ...        <span class="pl-c">% D0</span>
    HGpio.IN ...        <span class="pl-c">% D1</span>
    HGpio.IN ...        <span class="pl-c">% D2</span>
    HGpio.IN ...        <span class="pl-c">% D3</span>
    HGpio.OUT ...       <span class="pl-c">% D4</span>
    HGpio.OUT ...       <span class="pl-c">% D5</span>
    HGpio.OUT ...       <span class="pl-c">% D6</span>
    HGpio.OUT];         <span class="pl-c">% D7</span>
H.clock_Hz = <span class="pl-c1">3e6</span>;       <span class="pl-c">% Set clock rate to 3MHz (max frequency)</span>
H.timeout_ms = <span class="pl-c1">3000</span>;    <span class="pl-c">% Set the read/write timeout to 3000ms</span>

<span class="pl-c">%% Open the device and check status</span>
status = H.open();
<span class="pl-k">if</span> status; <span class="pl-k">error</span>(BusDriver.ERROR_CODES{status}); <span class="pl-k">end</span>

<span class="pl-c">%% Perform write and check status</span>
levelSet = [...         <span class="pl-c">% Set the level for (A/B)DBUS 0:7 to either HGpio.LOW or HGpio.HIGH</span>
    HGpio.LOW ...       <span class="pl-c">% D0 - Will have no effect, since pin is defined as HGpio.IN</span>
    HGpio.LOW ...       <span class="pl-c">% D1 - Will have no effect, since pin is defined as HGpio.IN</span>
    HGpio.LOW ...       <span class="pl-c">% D2 - Will have no effect, since pin is defined as HGpio.IN</span>
    HGpio.LOW ...       <span class="pl-c">% D3 - Will have no effect, since pin is defined as HGpio.IN</span>
    HGpio.HIGH ...      <span class="pl-c">% D4</span>
    HGpio.HIGH ...      <span class="pl-c">% D5</span>
    HGpio.LOW ...       <span class="pl-c">% D6</span>
    HGpio.LOW];         <span class="pl-c">% D7</span>

status = H.write(levelSet);
<span class="pl-k">if</span> status; <span class="pl-k">error</span>(BusDriver.ERROR_CODES{status}); <span class="pl-k">end</span>

<span class="pl-c">%% Perform read and check status - here we will see what was written before due to the hardwired loopback</span>
[levelGet, status] = H.read();
<span class="pl-k">if</span> status; <span class="pl-k">error</span>(BusDriver.ERROR_CODES{status}); <span class="pl-k">end</span>

<span class="pl-c">%% Measure execution time - we are quite snappy with ~125µs transaction time for a single write or read</span>
<span class="pl-k">tic</span>;
<span class="pl-k">for</span> <span class="pl-k">i</span>=<span class="pl-c1">1</span>:<span class="pl-c1">1000</span>; H.write(levelSet); <span class="pl-k">end</span>
elapsedTimeWrite_s = <span class="pl-k">toc</span>;
<span class="pl-k">disp</span>([<span class="pl-s"><span class="pl-pds">'</span>Elapsed time for 1000 writes /sec = <span class="pl-pds">'</span></span>, <span class="pl-k">num2str</span>(elapsedTimeWrite_s)]);

<span class="pl-k">tic</span>;
<span class="pl-k">for</span> <span class="pl-k">i</span>=<span class="pl-c1">1</span>:<span class="pl-c1">1000</span>; H.read(); <span class="pl-k">end</span>
elapsedTimeWrite_s = <span class="pl-k">toc</span>;
<span class="pl-k">disp</span>([<span class="pl-s"><span class="pl-pds">'</span>Elapsed time for 1000 reads  /sec = <span class="pl-pds">'</span></span>, <span class="pl-k">num2str</span>(elapsedTimeWrite_s)]);

<span class="pl-c">%% Close the device and check status</span>
status = H.close();
<span class="pl-k">if</span> status; <span class="pl-k">error</span>(BusDriver.ERROR_CODES{status}); <span class="pl-k">end</span></pre></div>

<h4>
<a id="an_002-interfacing-matlab-to-ics-via-uart" class="anchor" href="#an_002-interfacing-matlab-to-ics-via-uart" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>AN_002 <em>Interfacing MATLAB to ICs via UART</em>
</h4>

<p>Connect the pins and execute the file <em>AN_002.m</em> as follows</p>

<ul>
<li>ADBUS0 (D0) and ADBUS1 (D1), notably hardwired loopback of RX and TX</li>
</ul>

<pre><code>&gt;&gt; deviceId = 0;
&gt;&gt; AN_002(deviceId)
Hello BusDriver!
Elapsed time for loop around 1.0240 Mbyte = 0.97171
</code></pre>

<p>And here goes the code ... </p>

<div class="highlight highlight-source-matlab"><pre><span class="pl-c">% Application Note AN_002, version 1.0.0</span>

<span class="pl-k">function</span> <span class="pl-en">AN_002</span>(<span class="pl-v">devId</span>)
<span class="pl-c">%% Initialize the interface</span>
H = HUart();            <span class="pl-c">% Returns a GPIO object, H, to read and write via UART</span>
H.deviceNumber = devId; <span class="pl-c">% Must be 0 if only one device / channel is attached. Otherwise use 1, 2 etc.</span>
H.clock_Hz = <span class="pl-c1">12e6</span>;      <span class="pl-c">% HINT - Baudrate 12MHz is the unique feature compared to virtual com port!</span>

<span class="pl-c">%% Open the device and check status</span>
status = H.open();
<span class="pl-k">if</span> status; <span class="pl-k">error</span>(BusDriver.ERROR_CODES{status}); <span class="pl-k">end</span>

<span class="pl-c">%% Perform write/read and check status</span>
dataTx = <span class="pl-s"><span class="pl-pds">'</span>Hello BusDriver!<span class="pl-pds">'</span></span>;
[dataRx, status] = H.writeRead(dataTx);
<span class="pl-k">if</span> status; <span class="pl-k">error</span>(BusDriver.ERROR_CODES{status}); <span class="pl-k">end</span>

<span class="pl-k">disp</span>(<span class="pl-k">char</span>(<span class="pl-k">dataRx'</span>))

<span class="pl-c">%% Measure bandwidth - we reach ~1 MByte/s</span>
dataTx = <span class="pl-k">round</span>(<span class="pl-k">rand</span>(<span class="pl-c1">10240</span>, <span class="pl-c1">1</span>)*<span class="pl-c1">255</span>);

<span class="pl-k">tic</span>;
<span class="pl-k">for</span> idx = <span class="pl-c1">1</span>:<span class="pl-c1">100</span>; H.writeRead(dataTx); <span class="pl-k">end</span>
elapsedTimeWrite_s = <span class="pl-k">toc</span>;

<span class="pl-k">disp</span>([<span class="pl-s"><span class="pl-pds">'</span>Elapsed time for trasnfering 1.0240 Mbyte = <span class="pl-pds">'</span></span>, <span class="pl-k">num2str</span>(elapsedTimeWrite_s)]);

<span class="pl-c">%% Close the device and check status</span>
status = H.close();
<span class="pl-k">if</span> status; <span class="pl-k">error</span>(BusDriver.ERROR_CODES{status}); <span class="pl-k">end</span></pre></div>

<h4>
<a id="an_003-interfacing-matlab-to-ics-via-spi" class="anchor" href="#an_003-interfacing-matlab-to-ics-via-spi" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>AN_003 <em>Interfacing MATLAB to ICs via SPI</em>
</h4>

<p>Connect the pins and execute the file <em>AN_003.m</em> as follows</p>

<ul>
<li>ADBUS1 (D1) and ADBUS2 (D2), notably hardwired loopback of MISO and MOSI</li>
</ul>

<pre><code>&gt;&gt; deviceId = 0;
&gt;&gt; AN_003(deviceId)
Hello BusDriver!
Elapsed time/s for transferring 1.0240 Mbyte: 0.35617
</code></pre>

<p>And here goes the code ... </p>

<div class="highlight highlight-source-matlab"><pre><span class="pl-c">% Application Note AN_003, version 1.0.0</span>

<span class="pl-k">function</span> <span class="pl-en">AN_003</span>(<span class="pl-v">devId</span>)
H = HSpiMaster();       <span class="pl-c">% Returns a SPI object, H, to read from and write to</span>
H.deviceNumber = devId; <span class="pl-c">% Must be 0 if only one device / channel is attached. Otherwise use 1, 2 etc.</span>
H.spiMode = <span class="pl-c1">0</span>;          <span class="pl-c">% Can be either 0 (CPOL=0, CPHA=0) or 2 (CPOL=1, CPHA=0)</span>
H.clock_Hz = <span class="pl-c1">30e6</span>;      <span class="pl-c">% Set clock rate to 30MHz (max frequency)</span>
H.timeout_ms = <span class="pl-c1">3000</span>;    <span class="pl-c">% Set the read/write timeout to 3000ms</span>

<span class="pl-c">%% Open the device and check status</span>
status = H.open();
<span class="pl-k">if</span> status; <span class="pl-k">error</span>(BusDriver.ERROR_CODES{status}); <span class="pl-k">end</span>

<span class="pl-c">%% Perform write/read and check status</span>
dataTx = <span class="pl-s"><span class="pl-pds">'</span>Hello BusDriver!<span class="pl-pds">'</span></span>;
[dataRx, status] = H.writeRead(dataTx);
<span class="pl-k">if</span> status; <span class="pl-k">error</span>(BusDriver.ERROR_CODES{status}); <span class="pl-k">end</span>

<span class="pl-k">disp</span>(<span class="pl-k">char</span>(<span class="pl-k">dataRx'</span>))

<span class="pl-c">%% Measure bandwidth - we reach ~3 MByte/s</span>
dataTx = <span class="pl-k">round</span>(<span class="pl-k">rand</span>(<span class="pl-c1">10240</span>, <span class="pl-c1">1</span>)*<span class="pl-c1">255</span>);

<span class="pl-k">tic</span>;
<span class="pl-k">for</span> idx = <span class="pl-c1">1</span>:<span class="pl-c1">100</span>; H.writeRead(dataTx); <span class="pl-k">end</span>
elapsedTimeWrite_s = <span class="pl-k">toc</span>;

<span class="pl-k">disp</span>([<span class="pl-s"><span class="pl-pds">'</span>Elapsed time/s for transferring 1.0240 Mbyte: <span class="pl-pds">'</span></span>, <span class="pl-k">num2str</span>(elapsedTimeWrite_s)]);

<span class="pl-c">%% Close the device and check status</span>
status = H.close();
<span class="pl-k">if</span> status; <span class="pl-k">error</span>(BusDriver.ERROR_CODES{status}); <span class="pl-k">end</span></pre></div>

<h4>
<a id="an_004-interfacing-matlab-to-ics-via-i2c" class="anchor" href="#an_004-interfacing-matlab-to-ics-via-i2c" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>AN_004 <em>Interfacing MATLAB to ICs via I2C</em>
</h4>

<p>Connect the pins to a real device (loopback is not possible) and execute the file <em>AN_004.m</em> as follows</p>

<ul>
<li>ADBUS0 (D0) and Slave IC SCL</li>
<li>ADBUS1 (D1) and ADBUS2 (D2) and Slave IC SDA</li>
</ul>

<pre><code>&gt;&gt; deviceId = 0;
&gt;&gt; AN_004(deviceId)
   123

Elapsed time/s for 1000 writes: 0.53617
Elapsed time/s for 1000 reads:  0.65904
</code></pre>

<p>And here goes the code ... </p>

<div class="highlight highlight-source-matlab"><pre><span class="pl-c">% Application Note AN_004, version 1.0.0</span>

<span class="pl-k">function</span> <span class="pl-en">AN_004</span>(<span class="pl-v">devId</span>)
H = HI2cMaster();       <span class="pl-c">% Returns a I2C object, H, to read from and write to</span>
H.deviceNumber = devId; <span class="pl-c">% Must be 0 if only one device / channel is attached. Otherwise use 1, 2 etc.</span>
H.slaveAddress7Bit = <span class="pl-c1">64</span>;<span class="pl-c">% Must be the 7Bit I2C-slave address</span>
H.clock_Hz = <span class="pl-c1">100e3</span>;     <span class="pl-c">% Set clock rate to 100kHz (Normalmode)</span>
H.timeout_ms = <span class="pl-c1">3000</span>;    <span class="pl-c">% Set the read/write timeout to 3000ms</span>

<span class="pl-c">%% Open the device and check status</span>
status = H.open();
<span class="pl-k">if</span> status; <span class="pl-k">error</span>(BusDriver.ERROR_CODES{status}); <span class="pl-k">end</span>

<span class="pl-c">%% Perform write and check status</span>
<span class="pl-c1">register</span> = <span class="pl-c1">0</span>; <span class="pl-c">% arbitrary register</span>
dataTx = <span class="pl-c1">123</span>; <span class="pl-c">% Dummy data</span>
status = H.write(<span class="pl-c1">register</span>, dataTx);
<span class="pl-k">if</span> status; <span class="pl-k">error</span>(BusDriver.ERROR_CODES{status}); <span class="pl-k">end</span>

<span class="pl-c">%% Perform read and check status - here we will see what was written before</span>
numBytesToRead = <span class="pl-c1">1</span>;
[dataRx, status] = H.read(<span class="pl-c1">register</span>, numBytesToRead);
<span class="pl-k">if</span> status; <span class="pl-k">error</span>(BusDriver.ERROR_CODES{status}); <span class="pl-k">end</span>
<span class="pl-k">disp</span>(dataRx);

<span class="pl-c">%% Measure execution time - we are quite snappy with ~600µs transaction time for a single write or read</span>
<span class="pl-c">% Throughput could be further increased by writing/reading multiple bytes at once,</span>
<span class="pl-c">% when register auto increment is supported by your slave.</span>
<span class="pl-k">tic</span>;
<span class="pl-k">for</span> <span class="pl-k">i</span>=<span class="pl-c1">1</span>:<span class="pl-c1">1000</span>; H.write(<span class="pl-c1">register</span>, dataTx); <span class="pl-k">end</span>
elapsedTimeWrite_s = <span class="pl-k">toc</span>;
<span class="pl-k">disp</span>([<span class="pl-s"><span class="pl-pds">'</span>Elapsed time/s for 1000 writes: <span class="pl-pds">'</span></span>, <span class="pl-k">num2str</span>(elapsedTimeWrite_s)]);

<span class="pl-k">tic</span>;
<span class="pl-k">for</span> <span class="pl-k">i</span>=<span class="pl-c1">1</span>:<span class="pl-c1">1000</span>; H.read(<span class="pl-c1">register</span>, numBytesToRead); <span class="pl-k">end</span>
elapsedTimeWrite_s = <span class="pl-k">toc</span>;
<span class="pl-k">disp</span>([<span class="pl-s"><span class="pl-pds">'</span>Elapsed time/s for 1000 reads:  <span class="pl-pds">'</span></span>, <span class="pl-k">num2str</span>(elapsedTimeWrite_s)]);

<span class="pl-c">%% Close the device and check status</span>
status = H.close();
<span class="pl-k">if</span> status; <span class="pl-k">error</span>(BusDriver.ERROR_CODES{status}); <span class="pl-k">end</span></pre></div>

<h2>
<a id="under-the-hood--usb-to-serial-converter" class="anchor" href="#under-the-hood--usb-to-serial-converter" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Under the Hood – USB-to-serial converter</h2>

<p>Any FTDI USB-to-serial converter with one of the follwoing  ICs is supported by <em>BusDriver</em>:</p>

<ul>
<li>
<a href="http://www.ftdichip.com/Products/ICs/FT232H.htm">FT232H</a>, 1-channel </li>
<li>
<a href="http://www.ftdichip.com/Products/ICs/FT2232H.htm">FT2232H</a>, 2-channels </li>
<li>
<a href="http://www.ftdichip.com/Products/ICs/FT4232H.htm">FT4232H</a>, 4-channels</li>
</ul>
      </section>
    </div>
    <footer>
      <p>Project maintained by <a href="https://github.com/dspKitchen">dspKitchen</a></p>
      <p>Hosted on GitHub Pages &mdash; Theme by <a href="https://github.com/orderedlist">orderedlist</a></p>
    </footer>
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->
    
  </body>
</html>
