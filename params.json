{
  "name": "BusDriver Toolbox",
  "tagline": "IC Communication for MATLAB®",
  "body": "**Schedule** – *BusDriver* lets you interface MATLAB® directly to ICs performing analog and digital I/O. You can sense data for analysis and visualisation, generate data for control and test automation or even close the loop by inserting some fancy computations in between. It offers build-in support on high level abstraction for: \r\n\r\n* GPIO, [AN_001](#an_001-interfacing-matlab-to-ics-via-gpio)\r\n* UART, [AN_002](#an_002-interfacing-matlab-to-ics-via-uart)\r\n* SPI,  [AN_003](#an_003-interfacing-matlab-to-ics-via-spi)\r\n* I2C,  [AN_004](#an_004-interfacing-matlab-to-ics-via-i2c)\r\n\r\n**Shift up a Gear** – *BusDriver* supports MATLAB code generation capabilities to get your products real more quickly within a single tool chain. *BusDriver* is your powerfull companion driving you from rapid prototyping to series product development in no time.\r\n\r\n**Ticket Check** – *BusDriver* is released under commercial and [GNU GPL v.2](https://www.gnu.org/licenses/old-licenses/gpl-2.0.html) open source licenses. Once your project becomes commercialised GPLv2 licensing dictates that you need to either open your source fully or purchase a commercial license. DspKitchen offer commercial licenses without any GPL restrictions. [Contact us for pricing](https://github.com/dspKitchen).\r\n\r\n## **Next Stop** – Geeting Started with *BusDriver*\r\n\r\n1. Start up MATLAB win64 (Recommended is R2016a, but older versions will probably work fine)\r\n2. Downlaod and install *BusDriver* Toolbox from within MATLAB command window by executing the following lines of code\r\n\r\n\t```matlab\r\n\t%% Make installation directory\r\n\tinstallationDirectory = fullfile(pwd, 'BusDriverToolbox');\r\n\tmkdir(installationDirectory)\r\n\r\n\t%% Download and unzip BusDriver Toolbox\r\n\turlBusDriver = 'https://github.com/dspKitchen/BusDriverToolbox/archive/master.zip';\r\n\tunzip(urlBusDriver, installationDirectory);\r\n\r\n\t%% Add BusDriver Toolbox to seach path\r\n\taddpath(installationDirectory);\r\n\t```\r\n\t\r\n3. Plug in a [supported USB-to-serial converter](#supported-usb-to-serial-converter), e.g.\r\n\t* Mikroelektronika [click USB adapter](http://www.mikroe.com/click/usb-adapter/) (**Recommended** due to its superior choice of ready to use [click boards™](http://www.mikroe.com/click/))\r\n\t* Adafruit [FT232H Breakout](https://www.adafruit.com/products/2264) (**Hint** – This board is quite cheep)\r\n\t* FTDI [FT232H M232H-B](http://www.ftdichip.com/Products/Modules/DevelopmentModules.htm#UM232H-B) \t\r\n\t* FTDI [FT2232H mini module](http://www.ftdichip.com/Products/Modules/DevelopmentModules.htm#FT2232H_Mini)\r\n\t* FTDI [FT4232H mini module](http://www.ftdichip.com/Products/Modules/DevelopmentModules.htm#FT4232H_Mini) (**Hint** – For all those who operate up to 4 ICs in parallel)\r\n4. Check whether your USB-to-serial converter is recognised by *BusDriver*\t\r\n\r\n\t```\r\n\t>> deviceTable = BusDriver.getDevices()\r\n\tdeviceTable = \r\n\t            Description       SerialNumber    Flag    Type       ID       LocationID\r\n\t         _________________    ____________    ____    ____    ________    __________\r\n\t\r\n\t    0    'Dual RS232-HS A'    'A'             2       6       67330064    202017    \r\n\t    1    'Dual RS232-HS B'    'B'             2       6       67330064    202018    \r\n\t    \r\n\t>> deviceNumber = BusDriver.getDeviceNumber('Dual RS232-HS A')\r\n\tdeviceNumber =\r\n\t     0\r\n\t```\r\n\t\r\n5. You have done it - the engine runs fine! Now, attach an IC of choise to the USB-to-serial converter and let *BusDriver* hit the road.\r\n\r\n## Itinerary – On how to go with *BusDriver* \r\n#### AN_001 *Interfacing MATLAB to ICs via GPIO*\r\nConnect the pins and execute the file *AN_001.m* as follows\r\n* ADBUS0 (D0) and ADBUS4 (D4), notably hardwired loopback of D0 and D4\r\n* ADBUS1 (D1) and ADBUS5 (D5), notably hardwired loopback of D1 and D5\r\n* ADBUS2 (D2) and ADBUS6 (D6), notably hardwired loopback of D2 and D6\r\n* ADBUS3 (D3) and ADBUS7 (D7), notably hardwired loopback of D3 and D7\r\n\r\n```\r\n>> deviceId = 0;\r\n>> AN_001(deviceId)\r\nElapsed time for 1000 writes /sec = 0.16505\r\nElapsed time for 1000 reads  /sec = 0.18014\r\n\r\nans =\r\n\r\n     1     1     0     0     1     1     0     0\r\n```\r\n\t\r\nAnd here goes the code ... \r\n```matlab\r\n% Application Note AN_001, version 1.0.0\r\n\r\nfunction levelGet = AN_001(devId)\r\n%% Initialize the interface\r\nH = HGpio();            % Returns a GPIO object, H, to eighter drive or sense certain I/O-Pins\r\nH.deviceNumber = devId; % Must be 0 if only one device / channel is attached. Otherwise use 1, 2 etc.\r\nH.direction = [...      % Sets the direction for (A/B)DBUS 0:7 to either HGpio.IN or HGpio.OUT\r\n    HGpio.IN ...        % D0\r\n    HGpio.IN ...        % D1\r\n    HGpio.IN ...        % D2\r\n    HGpio.IN ...        % D3\r\n    HGpio.OUT ...       % D4\r\n    HGpio.OUT ...       % D5\r\n    HGpio.OUT ...       % D6\r\n    HGpio.OUT];         % D7\r\nH.clock_Hz = 3e6;       % Set clock rate to 3MHz (max frequency)\r\nH.timeout_ms = 3000;    % Set the read/write timeout to 3000ms\r\n\r\n%% Open the device and check status\r\nstatus = H.open();\r\nif status; error(BusDriver.ERROR_CODES{status}); end\r\n\r\n%% Perform write and check status\r\nlevelSet = [...         % Set the level for (A/B)DBUS 0:7 to either HGpio.LOW or HGpio.HIGH\r\n    HGpio.LOW ...       % D0 - Will have no effect, since pin is defined as HGpio.IN\r\n    HGpio.LOW ...       % D1 - Will have no effect, since pin is defined as HGpio.IN\r\n    HGpio.LOW ...       % D2 - Will have no effect, since pin is defined as HGpio.IN\r\n    HGpio.LOW ...       % D3 - Will have no effect, since pin is defined as HGpio.IN\r\n    HGpio.HIGH ...      % D4\r\n    HGpio.HIGH ...      % D5\r\n    HGpio.LOW ...       % D6\r\n    HGpio.LOW];         % D7\r\n\r\nstatus = H.write(levelSet);\r\nif status; error(BusDriver.ERROR_CODES{status}); end\r\n\r\n%% Perform read and check status - here we will see what was written before due to the hardwired loopback\r\n[levelGet, status] = H.read();\r\nif status; error(BusDriver.ERROR_CODES{status}); end\r\n\r\n%% Measure execution time - we are quite snappy with ~125µs transaction time for a single write or read\r\ntic;\r\nfor i=1:1000; H.write(levelSet); end\r\nelapsedTimeWrite_s = toc;\r\ndisp(['Elapsed time for 1000 writes /sec = ', num2str(elapsedTimeWrite_s)]);\r\n\r\ntic;\r\nfor i=1:1000; H.read(); end\r\nelapsedTimeWrite_s = toc;\r\ndisp(['Elapsed time for 1000 reads  /sec = ', num2str(elapsedTimeWrite_s)]);\r\n\r\n%% Close the device and check status\r\nstatus = H.close();\r\nif status; error(BusDriver.ERROR_CODES{status}); end\r\n```\r\n\r\n#### AN_002 *Interfacing MATLAB to ICs via UART*\r\nConnect the pins and execute the file *AN_002.m* as follows\r\n* ADBUS0 (D0) and ADBUS1 (D1), notably hardwired loopback of RX and TX\r\n\r\n```\r\n>> deviceId = 0;\r\n>> AN_002(deviceId)\r\nHello BusDriver!\r\nElapsed time for loop around 1.0240 Mbyte = 0.97171\r\n```\r\nAnd here goes the code ... \r\n\r\n```matlab\r\n% Application Note AN_002, version 1.0.0\r\n\r\nfunction AN_002(devId)\r\n%% Initialize the interface\r\nH = HUart();            % Returns a GPIO object, H, to read and write via UART\r\nH.deviceNumber = devId; % Must be 0 if only one device / channel is attached. Otherwise use 1, 2 etc.\r\nH.clock_Hz = 12e6;      % HINT - Baudrate 12MHz is the unique feature compared to virtual com port!\r\n    \r\n%% Open the device and check status\r\nstatus = H.open();\r\nif status; error(BusDriver.ERROR_CODES{status}); end\r\n\r\n%% Perform write/read and check status\r\ndataTx = 'Hello BusDriver!';\r\n[dataRx, status] = H.writeRead(dataTx);\r\nif status; error(BusDriver.ERROR_CODES{status}); end\r\n\r\ndisp(char(dataRx'))\r\n\r\n%% Measure bandwidth - we reach ~1 MByte/s\r\ndataTx = round(rand(10240, 1)*255);\r\n\r\ntic;\r\nfor idx = 1:100; H.writeRead(dataTx); end\r\nelapsedTimeWrite_s = toc;\r\n\r\ndisp(['Elapsed time for trasnfering 1.0240 Mbyte = ', num2str(elapsedTimeWrite_s)]);\r\n\r\n%% Close the device and check status\r\nstatus = H.close();\r\nif status; error(BusDriver.ERROR_CODES{status}); end\r\n```\r\n\r\n#### AN_003 *Interfacing MATLAB to ICs via SPI*\r\nConnect the pins and execute the file *AN_003.m* as follows\r\n* ADBUS1 (D1) and ADBUS2 (D2), notably hardwired loopback of MISO and MOSI\r\n\r\n```\r\n>> deviceId = 0;\r\n>> AN_003(deviceId)\r\nHello BusDriver!\r\nElapsed time/s for transferring 1.0240 Mbyte: 0.35617\r\n```\r\nAnd here goes the code ... \r\n\r\n```matlab\r\n% Application Note AN_003, version 1.0.0\r\n\r\nfunction AN_003(devId)\r\nH = HSpiMaster();       % Returns a SPI object, H, to read from and write to\r\nH.deviceNumber = devId; % Must be 0 if only one device / channel is attached. Otherwise use 1, 2 etc.\r\nH.spiMode = 0;          % Can be either 0 (CPOL=0, CPHA=0) or 2 (CPOL=1, CPHA=0)\r\nH.clock_Hz = 30e6;      % Set clock rate to 30MHz (max frequency)\r\nH.timeout_ms = 3000;    % Set the read/write timeout to 3000ms\r\n\r\n%% Open the device and check status\r\nstatus = H.open();\r\nif status; error(BusDriver.ERROR_CODES{status}); end\r\n\r\n%% Perform write/read and check status\r\ndataTx = 'Hello BusDriver!';\r\n[dataRx, status] = H.writeRead(dataTx);\r\nif status; error(BusDriver.ERROR_CODES{status}); end\r\n\r\ndisp(char(dataRx'))\r\n\r\n%% Measure bandwidth - we reach ~3 MByte/s\r\ndataTx = round(rand(10240, 1)*255);\r\n\r\ntic;\r\nfor idx = 1:100; H.writeRead(dataTx); end\r\nelapsedTimeWrite_s = toc;\r\n\r\ndisp(['Elapsed time/s for transferring 1.0240 Mbyte: ', num2str(elapsedTimeWrite_s)]);\r\n\r\n%% Close the device and check status\r\nstatus = H.close();\r\nif status; error(BusDriver.ERROR_CODES{status}); end\r\n```\r\n\r\n#### AN_004 *Interfacing MATLAB to ICs via I2C*\r\nConnect the pins to a real device (loopback is not possible) and execute the file *AN_004.m* as follows\r\n* ADBUS0 (D0) and Slave IC SCL\r\n* ADBUS1 (D1) and ADBUS2 (D2) and Slave IC SDA\r\n\r\n```\r\n>> deviceId = 0;\r\n>> AN_004(deviceId)\r\n   123\r\n\r\nElapsed time/s for 1000 writes: 0.53617\r\nElapsed time/s for 1000 reads:  0.65904\r\n```\r\n\r\nAnd here goes the code ... \r\n```matlab\r\n% Application Note AN_004, version 1.0.0\r\n\r\nfunction AN_004(devId)\r\nH = HI2cMaster();       % Returns a I2C object, H, to read from and write to\r\nH.deviceNumber = devId; % Must be 0 if only one device / channel is attached. Otherwise use 1, 2 etc.\r\nH.slaveAddress7Bit = 64;% Must be the 7Bit I2C-slave address\r\nH.clock_Hz = 100e3;     % Set clock rate to 100kHz (Normalmode)\r\nH.timeout_ms = 3000;    % Set the read/write timeout to 3000ms\r\n\r\n%% Open the device and check status\r\nstatus = H.open();\r\nif status; error(BusDriver.ERROR_CODES{status}); end\r\n\r\n%% Perform write and check status\r\nregister = 0; % arbitrary register\r\ndataTx = 123; % Dummy data\r\nstatus = H.write(register, dataTx);\r\nif status; error(BusDriver.ERROR_CODES{status}); end\r\n\r\n%% Perform read and check status - here we will see what was written before\r\nnumBytesToRead = 1;\r\n[dataRx, status] = H.read(register, numBytesToRead);\r\nif status; error(BusDriver.ERROR_CODES{status}); end\r\ndisp(dataRx);\r\n\r\n%% Measure execution time - we are quite snappy with ~600µs transaction time for a single write or read\r\n% Throughput could be further increased by writing/reading multiple bytes at once,\r\n% when register auto increment is supported by your slave.\r\ntic;\r\nfor i=1:1000; H.write(register, dataTx); end\r\nelapsedTimeWrite_s = toc;\r\ndisp(['Elapsed time/s for 1000 writes: ', num2str(elapsedTimeWrite_s)]);\r\n\r\ntic;\r\nfor i=1:1000; H.read(register, numBytesToRead); end\r\nelapsedTimeWrite_s = toc;\r\ndisp(['Elapsed time/s for 1000 reads:  ', num2str(elapsedTimeWrite_s)]);\r\n\r\n%% Close the device and check status\r\nstatus = H.close();\r\nif status; error(BusDriver.ERROR_CODES{status}); end\r\n```\r\n\r\n## Under the Hood – USB-to-serial converter\r\nAny FTDI USB-to-serial converter with one of the follwoing  ICs is supported by *BusDriver*:\r\n\r\n* [FT232H](http://www.ftdichip.com/Products/ICs/FT232H.htm), 1-channel \r\n* [FT2232H](http://www.ftdichip.com/Products/ICs/FT2232H.htm), 2-channels \r\n* [FT4232H](http://www.ftdichip.com/Products/ICs/FT4232H.htm), 4-channels\r\n",
  "google": "",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}